Cyber Security Base Project I

The idea of this exercise was to create a web application with at least five different security flaws from the OWASP top ten list (https://www.owasp.org/index.php/Top_10_2013-Top_10).

I made my application using the starter template, so the language is Java. You can copy/clone the application from Github, the address is https://github.com/EKettu/CSecProject1. The application is very simple (and of course unsafe), the idea is that people are able to choose from two events and sign up to one event. There are also two event organisers (Charlie, password “snoopy” and Jon, password “garfield”), who are able to log in to see who has signed up to their event. Organisers can delete unwanted people and also give VIP statuses to people of their choosing. There are several security issues with the application, first I’ll address the vulnerabilities that can be found using OWASP ZAP. Finding vulnerabilities with ZAP:1. Open OWASP ZAP2. Start the application on Netbeans normally, the address is http://localhost:80803. On the ZAP start page under the title “Welcome to the OWASP Zed Attack Proxy (ZAP)” you can find an input field “URL to attack:”. Write here “http://localhost:8080”.4. Press “Attack”5. ZAP will run for a while, when it is done, you can see on the left lower corner “Alerts”. Under this you should see “Cross Site Scripting”, “Buffer Overflow” and “Password Autocomplete in Browser” files. Clicking the files will provide more information on these vulnerabilities. OWASP ZAP was not able to find all vulnerabilities, so some additional testing is required. List of all vulnerabilities and fixing methods:A3-Cross-Site Scripting (XSS)Application uses Thymeleaf that usually escapes all text inputs, but in HTML-templates done.html and view.html use of “th:utext” instead of “th:text” enables XSS attacks since now text inputs (name and address of a person signing up to an event) are unescaped and an attacker can just insert some JavaScript into the name and address fields. If the script is in the name field, the script is executed right away when the signup is submitted (this can be found by using ZAP), but if the script is in the address field, it is executed only after an organiser has logged in to manage his event (ZAP is unable to find this). This vulnerability can be fixed by just changing “th:utext” attributes in done.html and view.html templates into “th:text”. A6-Sensitive Data ExposureZAP found Password Autocomplete in Browser vulnerability in the application, because autocomplete attribute in the form containing organiser’s password input is not disabled. The browser could store the password and retrieve it, which is not considered optimal security wise. This vulnerability is marked by ZAP as “low priority” (whereas XSS is “high priority”), but in any case it could be fixed by adding “autocomplete=”off”” attribute into the password input field. A7-Missing Function Level Access ControlThis vulnerability becomes evident when one logs in as either of the organisers. The application shows the persons signed up to an event only when someone is authenticated, but it doesn’t check if the view-page of an event belongs to the event’s organiser. Basically now since there is no proper authentication, Charlie is able to view Jon’s event and persons signed up, and organisers are able to delete each other’s signups. Since account IDs are also visible in plain text (e.g. localhost:8080/view/1), Charlie can just change number 1 in the address into number 2 and access Jon’s event. This vulnerability can be fixed by adding authentication and checkups for all methods in the class EventController, so that the methods make sure that the one authenticated is the event’s organiser (e.g. “authentication.getName() == event.getAccount().getUsername()”). A8-Cross-Site Request Forgery (CSRF)Thymeleaf usually adds a CSRF token automatically for an user session, but in this application this feature is disabled by adding a line “http.csrf().disable();” in SecurityConfiguration. Vulnerability can be fixed by removing this line. To find this vulnerability you have to either check the page source (no CSRF token field) or application's source code (class SecurityConfiguration). A9-Using Components with Known VulnerabilitiesIn SecurityConfiguration I added a minor vulnerability by changing BCryptPasswordEncoder() into StandardPasswordEncoder(), which is an older implementation of the PasswordEncoder(). StandardPasswordEncoder() can be used to encode passwords, but BCryptPasswordEncoder() is a better, more secure version, so it is advisable to change the application’s StandardPasswordEncoder() to a safer BCryptPasswordEncoder(). Finding this flaw requires studying the source code.A2-Broken Authentication and Session ManagementNormally Spring Security has session management enabled by default so that on authentication the old session is invalidated and a new session is created. The default line of code would be “http.sessionManagement().sessionFixation().migrateSession()”. In the applications SecurityConfiguration there is a line “http.sessionManagement().sessionFixation().none()”, which means that the original HTTP Session created will not be invalidated. This vulnerability will be fixed simply by removing this line. Application's source code must studied in order to find this vulnerability. 